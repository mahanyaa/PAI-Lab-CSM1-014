ROBOT PATH:

import heapq

# Map tile numbers to grid positions
tile_to_pos = {1:(0,0), 2:(0,1), 3:(0,2),
               4:(1,0), 5:(1,1), 6:(1,2),
               7:(2,0), 8:(2,1), 9:(2,2)}

start_tile = 1
goal_tile = 9

def h(pos):
    # Manhattan distance to goal
    gx, gy = tile_to_pos[goal_tile]
    return abs(pos[0]-gx) + abs(pos[1]-gy)

def neighbors(pos):
    x,y = pos
    for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
        nx,ny = x+dx, y+dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            yield (nx, ny)

def solve(start_tile):
    start_pos = tile_to_pos[start_tile]
    goal_pos = tile_to_pos[goal_tile]

    pq = [(h(start_pos), 0, start_pos)]
    parent = {start_pos: None}
    g = {start_pos: 0}

    while pq:
        _, cost, pos = heapq.heappop(pq)
        if pos == goal_pos:
            path = []
            while pos:
                path.append(pos)
                pos = parent[pos]
            return path[::-1]

        for nb in neighbors(pos):
            new_cost = cost + 1
            if nb not in g or new_cost < g[nb]:
                g[nb] = new_cost
                parent[nb] = pos
                heapq.heappush(pq, (new_cost + h(nb), new_cost, nb))

path = solve(start_tile)
print("Robot path from tile 1 to 9:")
for step in path:
    # print tile number
    tile = next(k for k,v in tile_to_pos.items() if v==step)
    print(f"Tile {tile} at position {step}")

OUTPUT:

Robot path from tile 1 to 9:
Tile 1 at position (0, 0)
Tile 2 at position (0, 1)
Tile 3 at position (0, 2)
Tile 6 at position (1, 2)
Tile 9 at position (2, 2)

=== Code Execution Successful ===