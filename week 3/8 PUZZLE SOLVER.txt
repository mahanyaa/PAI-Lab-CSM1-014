8 PUZZLE SOLVER

import heapq

goal = ((1,2,3),(4,5,6),(7,8,0))

def h(s):  # Manhattan distance
    return sum(abs(i-(v-1)//3) + abs(j-(v-1)%3)
               for i,row in enumerate(s)
               for j,v in enumerate(row) if v)

def neighbors(s):
    s = [list(r) for r in s]
    x,y = next((i,j) for i in range(3) for j in range(3) if s[i][j]==0)
    for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
        nx,ny = x+dx,y+dy
        if 0<=nx<3 and 0<=ny<3:
            t = [r[:] for r in s]
            t[x][y],t[nx][ny] = t[nx][ny],t[x][y]
            yield tuple(map(tuple,t))

def solve(start):
    pq = [(h(start),0,start)]
    parent = {start:None}
    g = {start:0}

    while pq:
        _,cost,state = heapq.heappop(pq)
        if state == goal:
            path=[]
            while state:
                path.append(state)
                state = parent[state]
            return path[::-1]

        for nb in neighbors(state):
            new_cost = cost+1
            if nb not in g or new_cost < g[nb]:
                g[nb] = new_cost
                parent[nb] = state
                heapq.heappush(pq,(new_cost+h(nb),new_cost,nb))

start = ((1,2,3),(4,5,6),(0,7,8))
sol = solve(start)


if sol:
    print("Number of moves:", len(sol)-1)
    for step in sol:
        print(*step, sep="\n"); print()
else:
    print("No solution")

OUTPUT:

Number of moves: 2
(1, 2, 3)
(4, 5, 6)
(0, 7, 8)

(1, 2, 3)
(4, 5, 6)
(7, 0, 8)

(1, 2, 3)
(4, 5, 6)
(7, 8, 0)


=== Code Execution Successful ===
